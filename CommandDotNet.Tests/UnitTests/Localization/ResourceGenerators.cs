using System;
using System.IO;
using System.Linq;
using System.Text.Json;
using CommandDotNet.Extensions;
using Xunit;
using Xunit.Abstractions;

namespace CommandDotNet.Tests.UnitTests.Localization
{
    public class ResourceGenerators
    {
        private readonly ITestOutputHelper _output;
        private static readonly string SolutionRoot = 
            new DirectoryInfo(Environment.CurrentDirectory).Parent!.Parent!.Parent!.Parent!.FullName!;

        public ResourceGenerators(ITestOutputHelper output)
        {
            _output = output;
        }
        
        // possible file formats: https://docs.lokalise.com/en/collections/2909121-keys-and-files#supported-file-formats
        // resx with IStringLocalizer is problematic because the keys are case-insensitive in the format so we 
        // cannot have "arguments" and "Arguments", though we need both.

        [Fact(Skip = "run to regenerate the ResourceProxy classes")]
        //[Fact]
        public void RegenerateProxyClasses()
        {
            var sources = ResourceProxyTests.ResourcesDefs.Select(r => r.source);
            
            var errors = sources.SelectMany(s => s.Validate()).ToList();
            if (errors.Any())
            {
                errors.ForEach(e => _output.WriteLine(
                    $"{e.error}:{Environment.NewLine}" +
                    $"  {e.members.ToCsv($"{Environment.NewLine}  ")}"));
                Assert.True(false);
            }

            var header = "// this file generated by " +
                         $"{GetType().Name}.{nameof(RegenerateProxyClasses)}{Environment.NewLine}";
            
            sources.ForEach(s =>
            {
                //File.Exists(path).Should().BeTrue("class should exist: {0}", path);
                var proxyClass = s.GenerateProxyClass();
                
                var path = Path.Combine(SolutionRoot, s.Type.Namespace, "ResourcesProxy.cs");
                File.WriteAllText(path, $"{header}{proxyClass}");
            });
        }
        
        [Fact(Skip = "run to regenerate the resx files. WARNING: some keys differ only in case and VS.NET will not open them.")]
        //[Fact]
        public void RegenerateResxFiles()
        {
            var proxies = ResourceProxyTests.ResourcesDefs.Select(r => r.proxy);

            var folder = Path.Combine(SolutionRoot, "CommandDotNet.Localization.Resx");
            
            proxies.ForEach(p =>
            {
                var path = Path.Combine(folder, $"{p.Type.Namespace}.resx");
                var resx = ResxWriter.Write(p.GetMembersWithDefaults());
                File.WriteAllText(path, resx);
            });
        }

        [Fact(Skip = "run to regenerate the json files")]
        //[Fact]
        public void RegenerateJsonFiles()
        {
            var proxies = ResourceProxyTests.ResourcesDefs.Select(r => r.proxy);

            var folder = Path.Combine(SolutionRoot, "localization");
            if (!Directory.Exists(folder))
            {
                Directory.CreateDirectory(folder);
            }
            
            proxies.ForEach(p =>
            {
                var dictionary = p.GetMembersWithDefaults()
                    .ToDictionary(t => t.value, t => t.value);
                var json = (string)JsonSerializer.Serialize(dictionary);
                var path = Path.Combine(folder, $"{p.Type.Namespace}.json");
                File.WriteAllText(path, json);
            });
        }
    }
}